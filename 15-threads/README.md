# Многопоточность

Сегодня у нас будет очень базовое введение в многопоточку: что такое потоки, зачем они нужны и как с ними работать в POSIX.

## Да кто такие эти ваши потоки

Классный ответ на stackoverflow: https://stackoverflow.com/a/19518207

Мы с вами знаем, что процессы это некоторая сущность в операционной системе, благодаря которой мы умеем не только одновременно исполнять несколько программ, но ещё и добиваться изоляции ресурсов одних процессов от других. Делается это при помощи механизма виртуальной памяти, переключения контекстов и тд. 
Также, мы помним, что создание нового процесса - тоже ничего себе операция: создание новых маппингов, copy-on-write и тд -- операции, вообще говоря, недешёвые. Оставили это на полях, очень скоро вернёмся к этому.

Теперь чуть про потоки. Первое, что о них можно сказать - их часто называют "легковесными процессами", но почему? Хотя бы потому, что они все делят память одного (родительского) процесса, а это значит что создание нового треда расчехляет огромный аппарат разметки страниц виртуального адресного пространства +  copy-on-write. Они делят одни и те же глобальные переменные, файловые дескрипторы, сигналы, в общем, почти всё, о чём вы можете подумать, кроме регистра PC (program counter, надеюсь во втором семестре акоса не нужно напоминать что это делает) и пользовтельских регистров, стека, и, собственно, состояния. 

Исходя из всего, что я написал, мы понимаем, что создавать и работать с потоками бывает сильно выгоднее, чем с процессами. Понимаем, что переключение контекстов между потоками (внутри одного процесса) сильно быстрее, потому что структуры ядра остаются теми же.

## Пользовательские потоки, зачем нужны и что делают
Кроме потоков ядра, есть ещё пользовательские потоки: они работают в пространстве пользователя, соответственно, для того, чтобы меджу ними переключаться, не нужно исполняться никакому коду ядра, понятно что это дешевле даже чем потоки ядра, но и тут не без недостатков: любой блокирующий сисколл заблокирует и поток, в котором исполняются ваши юзер-потоки, пока сисколл не закончится. 

Примеры таких библиотек:
https://graphitemaster.github.io/fibers/#n1-and-what-it-means
https://github.com/facebook/folly/tree/main/folly/fibers


# Как создаются треды?
[`pthread_create`](https://man7.org/linux/man-pages/man3/pthread_create.3.html)
[`pthread_join`](https://man7.org/linux/man-pages/man3/pthread_join.3.html)

Потоки создаются при помощи pthread_create() (на самом деле там под капотом сисколл `clone`), после создания потоков, вам нужно каким-то образом дождаться их завершения, для этого у нас есть функция pthread_join(), аналогично fork + waitpit.

Нужно понимать, что pthread - библиотека, которую нужно подключать к свеоему коду и она в свою очередь использует сисколы для того, чтобы избавить нас от необходимости каким-то образом синхронизировать работу потоков. Треды, например, создаются при помощи сиколла clone, давайте посмотрим на код этой функции, а ещё почекаем как мы самостоятельно можем создавать потоки без этих ваших библиотек. Пример тут, код имплементации тут 

Теперь простой пример работы с потоками посмотрим на простой пример [`simple-create-thread.c`](./simple-create-thread.c).

Тут нужно не забывать несколько вещей: 
1) `-pthreads`, иначе не заведётся ничего
2)`-fsanitize=address`, чтобы ловить очевидные (и не очень) баги (дедлоки, доступ к левой памяти и тд)
3) любой поток, который создаём, нужно заджойнить, иначе будут появляться потоки-зомби
4) не забываем освобождать память!


## Атрибуты потока
При создании потока, мы можем указать некоторые параметры работы потоков, они ещё называются атрибутмаи. Создаются они при помощи специальной функции pthread_attr_init(), освобождаются корректно при помощи pthread_attr_destroy();

https://man7.org/linux/man-pages/man3/pthread_attr_init.3.html

Примеры аттрибутов, которые мы можем менять у потока - размер и расположение стека, а также размер т.к. guard area - куска памяти, ниже стека, который по сути дырка в адресном пространстве, чтобы избежать проезда по памяти.

Пример который мы дружно спишем вот [отсюда](https://linux.die.net/man/3/pthread_create): [`threads/set-stack-size.c`](./threads/set-stack-size.c)
Попробуйте позапускать с этими параметрами: `-s 0x200000 hola salut servus`. Чекните насколько будут отличаться адреса вершин стека потоков в зависимости от этого параметра. 

Потоки могут принимать и возвращать какие-то значения, пример на эту тему можем посмотреть в  thread-value, thread-structs

## pthread_cancel, cancelation points 
Потоки, которые запущены, можно завершать внештатно, но нужно понимать, что делать это достаточно опасно, тк поток может владеть какими-то ресурсами. По дефолту потоки должны завершаться не абы где, а в специальных cancellation points - функциях, где есть проверка на внештатное завершение потока. 
https://man7.org/linux/man-pages/man3/pthread_cancel.3.html#:~:text=Asynchronous%20cancelability%20means%20that%20the,that%20is%20a%20cancellation%20point.

Список функций, которые это поддерживают вот тут: https://man7.org/linux/man-pages/man7/pthreads.7.html https://linux.die.net/man/3/pthread_setcanceltype

Поэтому, если эти функции не вызывать, то поток не сможет быть прерван.

Можно воспользоваться pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);. Тогда поток может быть прерван на уровне планировщика. То есть поток скорее всего доработает текущий выделенный квант времени, но на следующий квант уже не запустится. На маках вот например это не работает.

https://easylang.online/blog/sort_par.html

## Базовые понятия
Лучше чем Яковлев тут и не скажешь:
На всех современных процессорных архитектурах операции чтения и записи в память выровненных данных, размер которых не превышает машинного слова, являются атомарными. Однако, с точки зрения строгому следованию стандартам Си и C++, такое предположение неверно, и необходимо использовать специальные типы данных и атомарные операции.

Кроме того, операции над типами данных, размер которых превышает размер машинного слова, заведомо являются неатомарными. В первую очередь, такая проблема проявляется для 64-разрядных типов данных (double и int64_t) на 32-разрядных архитектурах.

Если несколько потоков или процессов обращаются к одной области памяти, причем один из потоков (процессов) производит запись, то такая ситуация называется гонкой данных (data race), и приводит к ситуации неопределенного поведения.

## Атомики
В с11 есть ключевое слово _Atomic - модификатор типа, который работает с атомарными данными. В СИ атомарными могут быть только типы, которые помещаются в машинное слово, если _Atomic стоять рядом с чем-то большим машинного слова, он не будет иметь смысла. Снова интерфейс:
Интерфейс: 
 * `void atomic_store(T* object, T value)`,
 * `void atomic_store_explicit(T* object, T value, memory_order order)` - сохранить значение в атомарную переменную.
 * `T atomic_load(T* object)`,
 * `T atomic_load_explicit(T* object, memory_order order)` - загрузить значение из переменной.
 * `T atomic_exchange(T* object, T new_value)`,
 * `T atomic_exchange_explicit(T* object, T new_value, memory_order order)` - заменить значение и вернуть предыдущее.
 * `_Bool atomic_compare_exchange_strong(T* object, T* expected, T new_value)`,
 * `_Bool atomic_compare_exchange_strong_explicit(T* object, T* expected, T new_value, memory_order success, memory_order failure)`,
 * `_Bool atomic_compare_exchange_weak(T* object, T* expected, T new_value)`,
 * `_Bool atomic_compare_exchange_weak_explicit(T* object, T* expected, T new_value, memory_order success, memory_order failure)` - сравнить два значения, в случае их равенства - заменить на новое, в противном случае - записать в `expected` значение `object`.
 * `T atomic_fetch_MOD(T* object, T operand)`,
 * `T atomic_fetch_MOD_explicit(T* object, T operand, memory_order order)` - получить значение переменной, после чего - модифицировать её. `MOD` можеть быть:
  - `add` - инкремент
  - `sub` - декремент
  - `and` - поразрядное "и"
  - `or` - поразрядное "или"
  - `xor` - поразрядное "исключающее или".

В операции `compare_exchange` вариант `weak` обычно работает быстрее, но может ложно возвращать значение `0` даже при равенстве значений в `object` и `expected`. В некоторых алгоритмах это бывает допустимо, например, если значение проверяется в цикле. Почему - подробнее расскажет Липовский.

## Мьютексы и критические секции
Смотрим пример использования [`mutex-example`](./mutex-example.c). Здесь нам надо было добиться того, чтобы потоки самостоятельно писала какие-то чиселки в наш "сервер". Попробуйте убрать лок/анлок на мьютексы, скомпилировать с -fsanitize=thread и посмотреть что будет.

В многопоточной программе, есть  т.н. критические секции - части программы, которые потоку нужно использовать самостоятельно. 
Что это значит? Это значит что другие потоки должны нас каким-то образом ждать, пока мы закончим все свои дела. 
Структура данных, которая позволяет выделять эти самые критические секции и быть уверенными, что какой-то участок кода будет проходиться только одним потоком - мьютекс.

Интерфейс:
 * `pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)` - инициализация мьютекса для его последующего использования. Если второй параметр `NULL`, то инициализируется обычный (не рекурсивный) мьютекс. Для создания нового инициализированного мьютекса с параметрами по умолчанию можно использовать макрос `PTHREAD_MUTEX_INITIALIZER`.
 * `pthread_mutex_destroy(pthread_mutex_t *mutex)` - уничтожить ранее созданный мьютекс.
 * `pthread_mutex_lock(pthread_mutex_t *mutex)` - захватить мьютекс. Если другой поток уже захватил его, то текущий поток приостанавливает свою работу.
 * `pthread_mutex_trylock(pthread_mutex_t *mutex)` - пытается захватить мьютекс. В случае успеха возвращает значение `0`, а если мьютекс уже занят, то значение `EBUSY`.
 * `pthread_mutex_unlock(pthread_mutex_t *mutex)` - освободить ранее захваченный мьютекс. В отличии от семафоров, освободить мьютекс может только тот поток, которые его захватил, в противном случае это приведет к ошибке `EPERM`.


## Пара слов про RWMutex
В RWMutex есть методы RLock, RUnlock, Lock и Unlock: 
RLock может взять сколько угодно потоков, но Lock сможет взять только один поток и только при отсутсвии потоков с RLock-ом.
https://www.ibm.com/docs/en/aix/7.2?topic=programming-using-readwrite-locks

## Кондвар 
Ещё один примитив синхронизации, который позволяет дождаться наступления какого-то события, например, готовности каких-то данных. Пример есть в [`cond-var-example.c`](./cond-var-example.c).

Интерфейс: 
  * `pthread_cond_init(pthread_cond_t *c, const pthread_condattr_t *attr)` - инициализации условной переменной. Второй параметр может быть `NULL` - в этом случае подразумевается использование переменной только в рамках одного процесса. Для инициализации условной переменной с параметрами по умолчанию используется макрос `PTHREAD_COND_INITIALIZER`.
  * `pthread_cond_destroy(pthread_cond_t *c)` - уничтожить условную переменную.
  * `pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m)` - ожидает нотификации условной переменной переменной `c`, временно разблокируя мютекс `m`. Перед вызовом мьютекс должен находиться в заблокированном состоянии, в противном случае - неопределенное поведение. После наступления события нотификации, мьютекс опять блокируется.
  * `pthread_cond_timedwait(pthread_cond_t *c, pthread_mutex_t *m, const struct timespec *timeout)` - то же, что и `pthread_cond_wait`, но ожидание прекращается по истечению указанного периода времени.
  * `pthread_cond_signal(pthread_cond_t *c)` - уведомляет один поток, для которого выполняется ожидание нотификации. В общем случае, поток выбирается случайным образом, если их несколько.
  * `pthread_cond_broadcast(pthread_cond_t *c)` - уведомляет все потоки, для которых выполняется ожидание нотификации.

Кондвар всегда нужно использовать в паре с каким-то мьютексом. Почему так? Проникаемся ответом на stackoverflow: https://stackoverflow.com/questions/2763714/why-do-pthreads-condition-variable-functions-require-a-mutex
Ещё чуть читаем про spurious wakeups:
- spurious wakeups https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups
