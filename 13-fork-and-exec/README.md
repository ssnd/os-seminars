# fork + exec

## Пролог 
`:(){ :|:& };:`

## 100500-ый раз про процессы
В UNIX-системах у нас есть возможность запускать несколько программ "одновременно" благодаря абстракции под названием процесс, которую мы с вами обсуждаем уже какое-то время. Сегодня обсудим интерфейс и механизмы ядра для создания новых процессов, а также всякие спецэффекты, которыми можно получить по шапке если не уметь этим интерфейсом пользоваться.

## Иерархия процессов
У каждого процесса есть некоторый номерок, называется он PID или Process ID. 
Кроме этого, между процессами существуют связи "предок-потомок", и из процессов работающих в системе должно получаться некоторое дерево процессов. Первый процесс, который запускается имеет PID=1, раньше это был процесс с названием init, сейчас скорее всего это systemd, sysV, launchd или journald или upstart, зависит от того насколько владелец компа старпёр и насколько компьютер перед вами - мак.

Почитать про все холивары и историю с PID=1 можно [тут](https://habr.com/ru/post/503816/) и [тут](https://habr.com/ru/post/307958/).


## Как создаются процессы?
Процессы создаются при помощи системного вызова fork(), он создаёт *почти* копию процесса.
С момент форка один и тот же код будет исполняться одновременно двумя программами (см комменты в simple-fork-example.c). В родительском процессе `fork`  вернёт pid ребёнка, а в ребёнке вернёт 0 (тут пид можно будет узнать при помощи функции getpid()).

Простой пример: simple-fork-example.c

## Fork, Page Faults & CoW
Мы с вами прошлые разы очень много обсуждали мехнизмы маппинга памяти. Так вот, в целях оптимизации, памяти новых процессов не копируется при форке. Вместо этого, странички помечаются как read-only и когда из какого-то из процессов (родительского или дочернего) происходит попытка доступа к памяти, ядро получает Page fault и обрабатывает его тем, что создаёт копию нужной страницы. Таким образом память для новых процессов особождается on-demand. Называется этот механизм Copy-on-Write, можно чуть подробнее прочитать о том что именно происходит внутри ядра вот [тут](https://tldp.org/HOWTO/KernelAnalysis-HOWTO-6.html).

## Чуточку про сигналы
Один из способов взаимодействия процессов - сигналы, мы о них подробнее поговорим в следующем семестре, пока нужно запомнить что это способ отправить какое-то сообщение по айдишнику другого процесса. Сигналы отправляются при помощи команды `kill`, о ней на данный момент материалов мана будет достаточно, подробнее будем обсуждать её дальше.

## Состояния процессов
Самые основные состояния процессов: [исходный код линукса](https://github.com/torvalds/linux/blob/master/include/linux/sched.h)

Если лень было открывать ссылку, то перечислил их тут: 
- `TASK_RUNNING` - либо он исполняется, либо он стоит в очереди на исполнение  
- `TASK_INTERRUPTIBLE` - ждём какой-то ресурс (конец сисколла) при этом принимаем сигналы или вейкап от ядра, если дождались  
- `TASK_UNINTERRUPTIBLE` - тоже самое, только не получаем сигналы (например при записи на диск). Иногда это называют uninterruptible sleep, про него иногда спрашивают на собесах. О том почему он будет существовать всегда можно почитать [тут](https://lwn.net/Articles/288062/)
- `TASK_ZOMBIE` -  родитель не дождался завершения процесса (чуть подробнее ниже).  
- `TASK_STOPPED` - остановили процесс дебаггером  
- `TASK_KILLABLE` - то же, что и TASK_UNINTERRUPTIBLE, но можно прерывать, больше об этом [тут](https://lwn.net/Articles/288056/)


### Зомби и сироты
Если сделать процесс, и не дождаться его завершения из родительского, он станет сиротой и его предком станет pid=1, пример в `orphan.c`

Если сделать процесс и не дождаться его завершения, то он станет зомби, потому что он будет занимать место в таблице процессов, чтобы его родитель мог дождаться его завершения. пример в `zombie.c`


### Disown, job control
Очень рекомендую почитать эту статейку: https://web.archive.org/web/20171121095450/https://blogs.oracle.com/ksplice/disown,-zombie-children,-and-the-uninterruptible-sleep
Тут очень простым языком рассказывают как восстанавливать процессы после ctrl+z, как смотреть запущенные джобы для какого-то процесса в bash и много других интересностей, которые могут внезапно оказаться полезными. 
<!---
## Disown+jobs demo
```
bash long.sh & twice
jobs
echo $$
# separate window
kill -SIGHUP pid
ps -o...

 
bash long.sh
ctrl+z
fg/bg %1
disown %1
exit from shell
kill -SIGHUP parent, see child in ps 

# ^^ same with python program, suspend 
```
-->

## Fork бомба и как с ней справляться
Форк бомба: тип атаки при которой вся таблица процессов ядра заполняется и из-за этого невозможно создать новый процесс чтобы убить форк бомбу. 
Если у вас нет открытого окна с командной строкой (процесса, который уже запущен), единственный способ её выключить  - перезагрузить комп ~~помянем комп Серёжи минутой молчания~~.

Если есть открытое окно с терминалом , можно, например убить все процессы юзера, или все процессы баша, в случае если форк бомба башовая. 

Убить форк бомбу сложно, а вот избежать её появления можно при помощи limit-ов. Можно, например, проставить максимальное количество процессов, которое может создаваться одним пользователем, тогда при запуске форк-бомбы у него новые процессы создаваться не будут, но при этом система будет работоспособна.

Почитайте в мане про флаги `-S`, `-a`, `-H`, `-u` про `ulimit`. 

## Разные вейты 
Про разные вейты можно почитать в [ридинге Яковлева](https://github.com/victor-yacovlev/fpmi-caos/tree/master/practice/fork#%D1%87%D1%82%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82%D0%B0-%D0%B4%D0%BE%D1%8)


## exec
Лучше чем [ридинг Яковлева](https://github.com/victor-yacovlev/fpmi-caos/tree/master/practice/exec-rlimit-ptrace) никто не скажет, поэтому копипаста оттуда:

Формальное описание системного вызова exec: [man 2 execve](http://ru.manpages.org/execve/2)

Системный вызов `exec` предназначен для замены программы текущего процесса. Как правило, используется совместно с `fork`, но не обязательно.

Си-оболочки для системного вызова `exec` имеют несколько разных сигнатур.

```
int execve(const char *filename,
           char *const argv[],
           char *const envp[]);           
int execvpe(.....) // параметры аналогично execve

int execv(const char *filename, char *const argv[])
int execvp(......) // параметры аналогично execv

int execle(const char *filename,
           const char arg0, ..., /* NULL */,
           const char env0, ..., /* NULL */);

int execl(const char *filename,
          const char arg0, ..., /* NULL */);
int execlp(......) // параметры аналогично execl

```

Различные буквы в суффиксах названий `exec` означают?
 * `v` или `l` - параметры передаются в виде массивов (`v`), заканчивающихся элементом `NULL`, либо в виде переменного количества аргументов (`l`), где признаком конца перечисления аргументов является значение `NULL`.
 * `e` - кроме аргументов программы передаются переменные окружения в виде строк `КЛЮЧ=ЗНАЧЕНИЕ`.
 * `p` - именем программы может быть не только имя файла, но и имя, которое нужно найти в одном из каталогов, перечисленных в переменной окружения `PATH`.

Возвращаемым значением `exec` может быть только значение `-1` (признак ошибки). В случае успеха, возвращаемое значение уже в принципе не имеет никакого смысла, поскольку будет выполняться другая программа.

Аргументы программы - это то, что передаётся в функцию `main` (на самом деле, они доступны из `_start`, поскольку располагаются на стеке). Первым аргументом (с индексом `0`), как правило, является имя программы, но это не является обязательным требованием.

Классическим способом запуска новой программы является пара системных вызовов:

```
if (0 == fork) {
  execlp(program, program, NULL);
  perror("exec"); exit(1);
}
```

Замена выполняемой программы с помощью `exec` оставляет неизменным многие аттрибуты процесса, например, открытые файловые дескрипторы, лимиты, и переменные окружения, установленные через `setenv`.

Таким образом, между вызовами `fork` и `exec` можно провести дополнительную настройку программы перед выполнением.

```
if (0 == fork) {
  // Заменить стандартные потоки ввода/вывода на файлы
  // (имитация операции >ВЫХОД <ВХОД в bash)
  close(0);
  close(1);
  /* 0 = */ open(in_file, O_RDONLY);
  /* 1 = */ open(out_file, O_WRONLY|O_CREAT|O_TRUNC, 0640);

  execlp(program, program, NULL);
  perror("exec"); exit(1);
}
```

Для того, чтобы случайно (в достаточно больших программах) не передать открытый файловый дескриптор новой программе, в системном вызове `open` предусмотрен флаг открытия `O_CLOEXEC`, который означает, что файл должен быть закрыт при вызове `exec`.



<!-- 
plan for 13.12
- test?
- fork, fork alternatives (vfork, clone), https://man7.org/linux/man-pages/man2/vfork.2.html https://man7.org/linux/man-pages/man2/clone.2.html
- remote: fork debugging  https://sourceware.org/gdb/onlinedocs/gdb/Forks.html set follow-fork-mode child/parent 
- fflush.c, (11-0.c)


- exec syscall https://man7.org/linux/man-pages/man3/exec.3.html
- exec-simple.c, exec-change-fd.c
- 12-0.c
- disown demo 

bash long.sh & twice
jobs
echo $$
# separate window
kill -SIGHUP pid
ps -o...

 
bash long.sh
ctrl+z
fg/bg %1
disown %1
exit from shell
kill -SIGHUP parent, see child in ps 

# ^^ same with python program, suspend 
-->