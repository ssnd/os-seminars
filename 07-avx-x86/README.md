# `x87`, `sse`, `avx`, instrinsics

## Чуть истории

### х87
Вся наша работа с ассемблерными инструкциями до сих пор состояла в перекладывании целых чиселок на разные регистры. Мы особо не задумывались о двух вещах: как складывать флоты и как складывать несколько чисел (целочисленных или флотов) одновременно. 

Поговорим о работе с вещественными числами.

По дефолту первые процессоры (по крайней мере те, которые были произведены Intel в 80-х годах) не умели в операции с вещественными чиселками от слова совсем. Если нужно было работать с флотами: делать эти операции используя всякие библиотеки, либо докупать со-процессор для более быстрой работы с флотами. Некоторым в те времена этот со-процессор был и вовсе ненужен, например людям которые работали с текстом. А вот тем, кто что-то считал, был смысл доплачивать за дополнительную железку которая ускорит математические операции.

Один пример такого со-процессора -  Intel 8087 (отсюда, наверное, пошло х87).Для работы с ним есть свои специальные инструкции.

Коротко о том как он был устроен: у нас есть стек из 8 значений (`st(0)`..`st(7)`).

Мы умеем с этим стеком делать следующие операции:
- Проводить какие-то операции над чиселками, которые лежат на стеке (унарные `FSQRT`, `FPTAN` + бинарные `FADD`, `FMUL`).
- Менять местами значения st(0) со значением какого-то друго го регистра (`FXCH`)
- `push`, `pop` на стек (с st(0))
- Загружать в память значение со стека (`FST`)

Позже (со слов википедии, начиная с Intel 80846) со-процессор был встроен в кристал, но синтаксис x87 продолжил поддерживалаться потому что легаси.

х87 до сих пор можно пользоваться, для этого нужен ~~простой советский~~  `-mfpmath=387` при компиляции. [Пример](https://godbolt.org/z/c73xxnGh5). Папочка x87 в помощь.

### ММX
В 1997 Intel выпустило Pentium P5, который поддерживал SIMD (single instruction multiple data) инструкции. MMX - это просто буквы, они официальным образом никак не расшифровываются.

Тут те же 8 регистров (mm0..mm7), но в них уже можно было складывать по одному 64-битному инту, два 32-битных, четыре 16 битных или 8 восьмибитных интов одновременно. 

Сам по себе MMX не поддерживал работу с флотами, но регистры при работе были на самом деле алиасами регистров х87. Поэтому если в программе нужны были операции и с MMX и флотами, нужно было делать отдельные приседания чтобы эти операции не мешали друг другу. 

MMX и вышедшая двумя годами позже 3DNow от AMD особую популярность не сыскали.

### SSE 
SSE (Streaming SIMD Extensions) вышла в 1999 вместе с третьим пентиумом году, тут уже были добавлены отдельные 128-битные регистры и можно было работать не только с интами, но и с флотами!

SSE обновляли до версий SSE2, SSE3, SSSE3, SSE4, SSE4.2 из самых известных. 

### AVX 
В 2008 Intel объявили что работают над процессорами, которые поддерживают AVX (Advanced Vector Extensions), в которых было шестнадцать 256-битных регистров, и логика "деления" тоже работала как раньше.

В xeon и i9 поддерживается расширение AVX-512, тут уже регистры стали 512-битными.

Больше про разные версии этих расширения, и про  то, что именно менялось в каждой версии, можно почитать [тут](https://www.techspot.com/article/2166-mmx-sse-avx-explained/)


## Названия регистров
128-битные регистры SSE именуются xmm0...xmm7, xmm8...xmm15.

256-битные регистры AVX ymm0...ymm15 подразумевают, что их младшие 128 бит совпадают с регистрами SSE.

512-битные регистры AVX-512 (новые Xeon и Core i9) zmm0...zmm31 подразумевают, что младшие 256 бит совпадают с регистрами AVX.

## Поехали писать 
Мы с вами будем пользоваться в основном AVX инструкицями, референс по ним можно найти вот [тут](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html). По этому гайду можно искать как названия интринсик функций, так и по названию ассемблерных инструкций. Очень удобная штука!

Большой референс по инструкциям х86:  
https://www.felixcloutier.com/x86/index.html 


### Регистры SSE и скаляры
Несмотря на свой большой размер, регистры SSE можно использовать как обычные скалярные, что намного эффективнее, чем x87 FPU.

В отличии от регистров в стеке st(0)...st(7), все регистры SSE являются равнозначными.

```
// Копирование регистр-регистр и регистр-память
movsd   DST, SRC  // пересылка double
movss   DST, SRC  // пересылка float

// Арифметические
addsd   DST, SRC   // DST += SRC, double
addss   DST, SRC   // DST += SRC, float
subsd   DST, SRC   // DST -= SRC, double
subss   DST, SRC   // DST -= SRC, float
mulsd   DST, SRC   // DST *= SRC, double
mulss   DST, SRC   // DST *= SRC, float
divsd   DST, SRC   // DST /= SRC, double
divss   DST, SRC   // DST /= SRC, float
sqrtsd  DST, SRC   // DST = sqrt(SRC), double
sqrtss  DST, SRC   // DST = sqrt(SRC), float
maxsd   DST, SRC   // DST = max(DST, SRC), double
maxss   DST, SRC   // DST = max(DST, SRC), float
minsd   DST, SRC   // DST = min(DST, SRC), double
minss   DST, SRC   // DST = min(DST, SRC), float

// Преобразования
cvtsd2si DST, SRC  // double -> int
cvtsi2sd DST, SRC  // int -> double

// Сравнения (операция DST-SRC, которая меняет флаги)
comisd  DST, SRC  // для double
comiss  DST, SRC  // для float
```


### Про calling conventions
Значение возврата кладётся на регистр xmm0, аргументы вызова функции находятся на xmm0..xmm7 , остальное на стеке. Пример можно посмотреть в `args`.

Если в сигнатуре функции используются целочисленные и вещественные регистры, то они будут совмещаться, те для вещественных будут использоваться xmm0..xmm7 по порядку, а для целочисленных rsi, rdi и тд.

Пример тут: https://godbolt.org/z/W5dzM7681

### Сумма
```asm
add:
	addsd	xmm0, xmm0, xmm1
	ret
```


Расшифровочка команды:  
```
addsd
^  ^^
|  ||
|  |+---> double-precision
|  +----> scalar
+---> ну add и add чо бубнить
```

Делать другие простые операции с чиселками оставим как упражнение для читателя на чтение мануала. 

(Почти) каждую строчку из кода ниже рекомендую по мере чтения кода смотреть в мануале.

### Сумма 8 флотов за один присест
```
.intel_syntax noprefix

.text
.global vadd

vadd:
    vmovups ymm2, YMMWORD PTR [rsi]
    vmovups ymm1, YMMWORD PTR [rdi]

    vaddps ymm0, ymm1, ymm2

    vmovups YMMWORD PTR [rdx], ymm0
    ret
```

Понятное дело, что таким же макаром можно, например, складывать много интов разом, нужно просто найти нужную команду в мануале.

### Эти же инструкции можно использовать как сишные функции
Давайте попробуем!
Перед тем как пользоваться нашими чиселками при помощи интринсик функций, их надо подгрузить на регистры с которыми работает AVX.
Несколько вариков:
1) `vmovups ymm2, YMMWORD PTR [rsi]` -- тут всё понятно, кладём на 256-битный регистр содержимое YMMWORD размера с указателя первого аргумента функции. Но это не си.
2) Си: `__m256 a = _mm256_set_ps(1.,2.,3.,4.,5.,6.,7.,8.);` Set packed single-precision (32-bit) floating-point elements in dst with the supplied values.
3) Ещё раз си:  
```c
float a[] = {1.,2.,3.,4.,5.,6.,7.,8.};
__m256 a_2 = _mm256_loadu_ps(a);
```  
А потом пользуемся этим делом.

Ещё примеры на это можно посмотреть в папочке `avx-basic-operations/*`.

### Чуть про то как писать оптимальный си-код
Эта часть целиком и полностью вдохновлена (вплоть до нейминга переменных и функций) семинарами Печатнова. Поэтому тем, кто не пришёл на семинар где мы обсуждаем все эти вещи я **настоятельно** рекомендую посмотреть [часть](https://youtu.be/obufMgdWPKI?t=1540) семинара Печатнова, где он проходится по этим вещам.

Пишем простой как палку код:
```c
void sum_0(const int* a, const int * b, int *c) {
    for (size_t i = 0; i < 4; ++i ){
        c[i] = a[i] + b[i];
    }
}
```

Смотрим во что он у нас компилится:

```asm
sum_0:
.LFB5307:
	.cfi_startproc
	endbr64
	lea	rax, 15[rdi] // какое-то сравнение
	sub	rax, rdx
	cmp	rax, 30
	jbe	.L2 // какой-то прыжок к какой-то метке
	lea	rax, 15[rsi]
	sub	rax, rdx
	cmp	rax, 30
	jbe	.L2
	vmovdqu	xmm0, XMMWORD PTR [rsi]
	vpaddd	xmm0, xmm0, XMMWORD PTR [rdi]
	vmovups	XMMWORD PTR [rdx], xmm0
	ret
	.p2align 4,,10
	.p2align 3
.L2:
	mov	eax, DWORD PTR [rsi]
	add	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR 4[rsi]
	add	eax, DWORD PTR 4[rdi]
	mov	DWORD PTR 4[rdx], eax
	mov	eax, DWORD PTR 8[rsi]
	add	eax, DWORD PTR 8[rdi]
	mov	DWORD PTR 8[rdx], eax
	mov	eax, DWORD PTR 12[rsi]
	add	eax, DWORD PTR 12[rdi]
	mov	DWORD PTR 12[rdx], eax
	ret
```

Можно заметить что тут есть по сути две реализации нашей простой функции: одна в которой логика написана при помощи векторных инструкций, другая  в которой вручную складываются чиселки.

Если коротко, то в этой функции вначале происходит проверка пересечения областей памяти, которые лежат у нас в первом и втором аргументе. Если эти области пересекаются то каждая итерация цикла будет зависеть от следующей, и тут уже векторными операциями воспользоваться не выйдет.


Второй подход:
```c
void sum_1(const int * restrict a, const int * restrict b, int * restrict c) {
    for (size_t i = 0; i < 4; ++i ){
        c[i] = a[i] + b[i];
    }
}
```

Тут мы используем ключевое слово restrict, которая служит подсказкой для компилятора. Тут мы гарантируем, что другой указатель не будет использован для доступа к этому объекту. Это позволяет компилятору делать всякие оптимизации, в том числе используя векторные инструкции.

Смотрим ассемблер: 
```asm
sum_1:
.LFB5308:
	endbr64
	movdqu	xmm0, XMMWORD PTR [rsi]
	movdqu	xmm1, XMMWORD PTR [rdi]
	paddd	xmm0, xmm1
	ret
```


Тут уже получше, нет прыжков в разные секции и странных проверок, но всё ещё используются инструкции `movdqu` (Move **Unaligned** Double Quadword) и `movups` (Move **Unaligned** Packed Single-Precision Floating-Point Values). А нам нужно aligned, потому что выровненные значения загружаются в память быстрее....



Третий подход:
```c
void sum_2(const int* restrict a_, const int* restrict b_, int* restrict c_) {
    const int * a = __builtin_assume_aligned(a_, 16);
    const int * b = __builtin_assume_aligned(b_, 16);
    int * c = __builtin_assume_aligned(c_, 16);

    for (size_t i =0; i < 4; ++i ){
        c[i] = a[i] + b[i];
    }
}
```

Тут мы воспользовались не только ключевым словом `restrict`, но ещё и и интринсиком `__builtin_assume_aligned`, который подсказал компилятору, что память на входе будет выровненная.  

Смотрим ассемблер:
```asm

sum_2:
.LFB5309:
	endbr64
	movdqa	xmm0, XMMWORD PTR [rsi]
	paddd	xmm0, XMMWORD PTR [rdi]
	movaps	XMMWORD PTR [rdx], xmm0
	ret
```

Поздравляю, мы молодцы!


### Место для разбора нулёвки построчно с дебаггером и референсом
Я постарался очень подробно откоментировать нулёвку, разбирать её тут дополнительно не вижу смысла. Самое важное там - разобраться с инструкциями и тем, что они делают.