# Сигналы

Полезные ссылки:
- Ридинг Яковлева https://github.com/victor-yacovlev/fpmi-caos/blob/master/practice/signals
- Ридинг Печатнова https://github.com/yuri-pechatnov/caos/tree/master/caos_2020-2021/sem15-signal
- Очень интересная книжка Advanced Programming in the Unix Environment, W. Richard Stevens. [Выдержку в пдф](./APUE-3rd-signals.pdf) с частью про сигналы я оставил в репе. Структуру и многие объяснения для этого семинара нагло взял оттуда.


## Что такое сигналы?
Сигнал - это механизм передачи коротких сообщений (номер сигнала), как правило, прерывающий работу процесса, которому он был отправлен.

Сигналы могут быть посланы процессу:
- ядром, как правило, в случае критической ошибки выполнения;
- другим процессом;
- самому себе.

У сигналов есть имена, все эти имена начинаются с трёх магических букв SIG, каждому сигналу соответствует номерок строго больше нуля. Номерки эти можно найти в заголовочном файлике с названием `signal.h`. 
Сигнал с номером 0 используется для специальных кейсов, он называется `null signal` и о нём можно почитать с прикреплённой пдфке или если мне не будет лень расписывать это в конце ридинга.

Сигналы появляются как результат:
- Действий пользователя (`Ctrl+C` - `SIGINT`, `Ctrl+\` - сигнал `SIGQUIT`, `Ctrl+Z` - `SIGTSTP`)
- Аппаратные исключения (так говорят вообще?) - деление на ноль, обращение к невалидной памяти и т.д. Пример тут страшный, конечно: `SIGSEGV` - бу!
- Вызова функции `kill(1)` и `kill(2)`
- Каких-то программных настроек самих програм, примеры: `SIGURG`, `SIGALRM`, `SIGPIPE` (помните его?).

Что можно делать с сигналами:
- Игнорировать: для всех сигналов, кроме SIGSTOP+SIGKILL, как думаете почему?
- Навесить свой обработчик на сигнал, совсем скоро увидим как.
- Ничего не трогать, тогда произойдёт действие, которое навешено на сигнал по умолчанию.

Сигналы асинхронные, это означает, что он может прилететь когда угодно и мы заранее не можем в нашей программе знать когда она будет (или не будет) прервана сигналом.

Давайте глянем [картинку](./signal-table.png). Что за core?

## Core-dump и как его читают 
Часто ведь у вас бывало, что вы написали какую-нибудь задачку по алгосам, она запустилась, ничо не вывела и в терминале осталась одинокая строчка `чототам (core dumped)`. Оказывается, дамп это некоторые снепшот состояния программы перед тем как всё стало очень плохо. И его можно читать!

Давайте пробовать
Первое, что надо сделать - это неиронично написать код, который будет вызывать сигнал с кордампом. Например, вот такой:
```c
#include <signal.h>

void my_buggy_function(void) {
    raise(SIGABRT);
}

int main() {
    my_buggy_funcion();
}
```
- Проверяем ulimit -c - он много где по дефолту ограничивает размер дампа нулём
- `сat /proc/sys/kernel/core_pattern`
- На моей тачке надо было сделать sudo service apport stop, почитайте про это кому интересно 

А потом мэджик: запускаем программу и делаем gdb ./a.out core + bt full и видим где наша программа кончилась. Профит! 

## Как было раньше? Original & Reliable signals
Небольшой экскурс в историю: в предыдущих системах UNIX сигналы были ненадёжные, по пунктам, почему так
1) Сигнал мог потеряться потому что потому что 
2) Не было возможности отключать сигналы на время, можно было полностью их игнорировать, либо нужно обязательно как-то обрабатывать. Что в этом случае делать с сигналами, которые нужно на время заблокировать? 
3) Обработчики сигналов нужно было переподвешивать после каждого использования. В коде это выглядело так: 

```c
int sig_int() {
   signal(SIGINT, sig_int);   /* reestablish handler for next time */
}

int main() {
   signal(SIGINT, sig_int);      /* establish handler */ 
}
```
А теперь представьте что произойдёт, если между запуском обработчика и навешиванием обработчика внутри обработчике произойдёт сигнал? Произойдёт дефолтное действие, процесс завершится. А нам этого не надо.

За весь этот ужас отвечает легаси функция `signal()`, о которой мы будем помнить, но которой мы не будем пользоваться. 
Не будем пользоваться, потому что на смену ей пришли т.н. reliable signals вместе с функцией sigaction - через которую можно выразить signal, но не наоборот. Пользуясь ей можно, в частности, временно блокировать сигналы,  навешивать обработчики раз и навсегда и т.д.

Устроена она так:
```c
#include <signal.h>

int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);

struct sigaction {
  void     (*sa_handler)(int);  /* addr of signal handler, */
                                /* or SIG_IGN, or SIG_DFL */
  sigset_t sa_mask;             /* additional signals to block */
  int      sa_flags;            /* signal options, Figure 10.16 */
  /* alternate handler */
  void     (*sa_sigaction)(int, siginfo_t *, void *);
};
```

## async-signal safety
Перед тем как пойдём писать код и смотреть примерчики, надо упомянуть ещё пару вещей: прерывать абы какими обработчиками сигналов программы, конечно же, нельзя. Пример того как можно всё сломать: давайте представим себе, что мы используем какой-нибудь маллок, который внутри работает, например, с каким-нибудь связным списком. Прилетел сигнал, маллок не закончил,  не закончит свою работу, а мы возьмём и эту же функцию ещё раз вызовем. Получится бо-бо, а чтобы такого не происходило, нужно использовать async-signal safe фукнции

`man signal-safety`

Если коротко, то есть список функций, которые можно использовать внутри обработчиков сигналов + sig_atomic_t. Дальше можно почитать в мане.

Первый примерчик: simple-example.c
## real-time signals vs reliable signals
Real-time сигналы, в отличие от обычных сигналов, доставляются по очереди и столько раз, сколько были отправлены. Номера таких сигналов - от SIGRTMIN до SIGRTMAX
Тырим пример у Печатнова, осознаем что real-time сигналы не работают на маках и тихо плачем(
пример: rt-signals.c

## SIGCHLD & SIGARLM
примеры: finished-child-process.c, sig-alarm.c
Тут всё очень прозрачно

## kill
man kill 
kill -9 <pid>

kill -SIGHUP <pid> чтобы отправить SIGHUP какому-то конкретному процессу

## Signal sets
Когда процессу приходит сигнал, в некоторой его маске проставляется битик, эта маска умеет хранить только информацию о том что сигнал пришёл. Если пришло несколько сигналов, мы об этом знать не будем. Как только запустится обработчик сигнала, битик занулится. Эта маска называется маской доставки сигналов и она не наследуется при форке.

Помимо неё есть ещё и маска сигналов - это маска, в которой можно прописывать заблокированные сигналы, она уже при  форке наследуется.
Множества сигналов описываются типом данных sigset_t, объявленным в заголовочном файле <signal.h>.

Операции над множествами:

sigemptyset(sigset_t *set) - инициализировать пустое множество;
sigfillset(sigset_t *set) - инициализировать полное множество;
sigaddset(sigset_t *set, int signum) - добавить сигнал к множеству;
sigdelset(sigset_t *set, int signum) - убрать сигнал из множества;
sigismember(sigset_t *set, int signum) - проверить наличие сигнала в множестве.

пример mask-block-all.c