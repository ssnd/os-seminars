# Файлы и дескрипторы

Для начала небольшой рекап с прошлого раза + закрываем гештальт с режимами исполнения и примером перехода из пользовательского режима в привилегерованный

# Да кто такие эти ваши файловые дескприторы
Файловые дескприторы - неотрицательные чиселки, они идентифицируют файлы внутри одного процесса. Внутри каждого процесса есть т.н. таблица файловых дескрипторов.
В любом UNIX процессе (кроме демонов) 0, 1 и 2 при создании это файловые дескприторы потока ввода, вывода и ошибок соответственно.

смотрим proc.h из xv6:
```c
// Per-process state
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID
  // ....
  struct file *ofile[NOFILE];  // Open files <-- the list of file descriptors
  // ....
};
```

А что за `struct file`?

```c
struct file {
  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;
  int ref; // reference count
  char readable;
  char writable;
  struct pipe *pipe; // FD_PIPE
  struct inode *ip;  // FD_INODE and FD_DEVICE
  uint off;          // FD_INODE
  short major;       // FD_DEVICE
};
```

Из-за того, что я не знаю сколько времени у нас займёт обсуждение, мы сначала обсудим более высокоуровневые детали, а в более низкий уровень обсудим на следующем семинаре. 


Внимание, ниже будут вопросики, которые иногда встречаются на собесах!

## Как смотреть открытые файловые дескрипторы для процесса?
`lsof -p <pid>`, пробуем это сделать для `sleep 1000 & , lsof -p` - создастся новый процесс, он начнёт выполняться и выдаст нам свой айди. Увидим, что даже в процессе который ничего не пишет ни в какой поток вывода и не читает из потока ввода, будут открыты свои файловые дескрипторы.

Подробнее про lsof можно почитать в рекламной [статейке на хабре](https://habr.com/ru/company/ruvds/blog/337934/), инструмент достаточно мощный и полезный. (или `man lsof + /OUTPUT`)

Кроме этого, есть возможность воспользоваться [`procfs`](https://en.wikipedia.org/wiki/Procfs).
Давайте поиграемся посмотрим. Напишем скрипт, который перенаправляет поток вывода в файл, посмотрим, на его айди, заглянем в /proc и посмотрим какая там есть инфа про процесс.

Мораль: `/proc/<pid>/fd` выдаёт все открытые фалйовые дескрипторы, в них можно смотреть (но не всегда) и в них можно что-то писать. В /proc/<pid> вообще достаточно много полезной инфы.

Всё что выше - полезные инструмент для "диагностики" и понимания что происходит с процессами в вашей системе. **Важно - это неподходящий инструмент для надёжной коммуникации/взаимодействия между процессами**, такие инструменты мы изучим в следующем семестре.

## Soft links / hard links
Если лень было ходить на семинар: https://medium.com/@307/hard-links-and-symbolic-links-a-comparison-7f2b56864cdd

утилита `stat` показывает инфу про наши файлики.
ln создаёт ссылки, жёсткие или символические

ln - создаёт жёсткую ссылку, это по сути другое название того же файла. Об этом можно безопасно думать как об "указателе на ту же память на диске". Файл удаляется с диска тогда, когда у него 0 жёстких ссылок. 

Давайте поиграемся с этим:
```bash
> ln some_file some_file2
> ll 
> stat some_file
> strace rm some_file # there's no 'delete' syscall, only 'unlink'
```


ln -s создаёт символическую ссылку на **путь** к файлу. Это просто указатель на файл (не на память на диске). Соответственно, если файл перенести (поменять адрес), то указатель сломается.

## ll / ls -la
Ридинг Яковлева в помощь: 
В случае создания файла, обязательным параметром является набор POSIX-аттрибутов доступа к файлу. Как правило, они кодируются в восьмиричной системе исчисления в виде 0ugo, где u - права доступа для владельца файла, g - права доступа для всех пользователей группы файла, o - для остальных.

В восьмеричной записи значения от 0 до 7 соответствуют комбинации трёх бит:
```
00: ---
01: --x
02: -w-
03: -wx
04: r--
05: r-x
06: rw-
07: rwx
```

## Как открываем/закрываем файлы из СИ
При помощи сисколла `open`, `man open` в помощь, основное ниже.

Сигнатура:
```c
int open(const char *path, int oflag, ... /* mode_t mode */);
```

Параметры:  
- `O_RDONLY` - только для чтения;
- `O_WRONLY` - только на запись;
- `O_RDWR` - чтение и запись;
- `O_APPEND` - запись в конец файла;
- `O_TRUNC`- обнуление файла при открытии;
- `O_CREAT` - создание файла, если не существует;
- `O_EXCL` - создание файла только если он не существует.


Закрываем при помощи (внезапно) [close](https://man7.org/linux/man-pages/man2/close.2.html)


Дальше цитируем Яковлева: 
Чтение и запись осуществляются с помощью системных вызовов:
```c
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
```

Здесь `buf` - указатель на буфер данных, а `count` - максимальное количество байт для чтения/записи.

Как правило, в `count` указывается размер буфера данных при чтении, или количество данных при записи.

Возвращаемый тип `ssize_t` - целочисленный, определенный в диапазоне `[-1...SSIZE_MAX]`, где `SSIZE_MAX` обычно совпадает с `SIZE_MAX/2`. Значение -1 используется в качестве признака ошибки, неотрицательные значения - количество записанных/прочитанных байт, которое может быть меньше, чем count.

Если системный вызов `read` вернул значение 0, то достигнут конец файла, либо был закрыт канал ввода.

Навигация по файлу в `POSIX`
Если файл является обычным, то можно выполнять перемещение текущей позиции в файле.

```c
off_t lseek(int fd, off_t offset, int whence);
```
Этот системный вызов предназначен для перемещения текущего указателя на файл.

Третий параметр whence один из трех стандартных способов перемещения:

`SEEK_SET` - указать явным образом позицию в файле;
`SEEK_CUR` - сместить указатель на определенное смещение относительно текущей позиции;
`SEEK_END` - сместить указатель на определенное смещение относительно конца файла.
Системный вызов `lseek` возвращает текущую позицию в файле, либо значение -1 в случае возникновения ошибки.


# Код
`file-read-write.c` всё просто, открываем файл, получаем файловый дескриптор, осознаём что в него можем писать. Играемся с флагами. 

`read-from-stdin.c` умеем вводить с клавиатуры, умеем подменять поток ввода, осознаём, что стдин - тот же файловый дескриптор. понимаем что рид не очень умный (не умеет ждать данные) , поэтому его нужно ретраить, пока не получим все нужные данные. Тырим ретрай Печатнова


В lseek пример работы с lseek, тут всё оч просто.

## open и флаги
Если в open вы проставили флаг O_TMPFILE или O_CREAT, то нужно будет проставить флаги доступа
Их можно вставить просто циферками (0644, 0755 и тд).
Либо можно комибинируя заранее приготовленные константы:
```
S_IRW[XU  00700 user (file owner) has read, write, and
         execute permission

S_IRUSR  00400 user has read permission

S_IWUSR  00200 user has write permission

S_IXUSR  00100 user has execute permission

S_IRWXG  00070 group has read, write, and execute
         permission

S_IRGRP  00040 group has read permission

S_IWGRP  00020 group has write permission

S_IXGRP  00010 group has execute permission

S_IRWXO  00007 others have read, write, and execute
         permission

S_IROTH  00004 others have read permission

S_IWOTH  00002 others have write permission

S_IXOT]H  00001 others have execute permission
```
